library IEEE;
use ieee.std_logic_1164.all; 
use ieee.numeric_std.ALL;
use ieee.std_logic_unsigned.all; 
use work.Constants.all;

--
-- This entity is a wrapper for the memory controller generated by Xilinx's MIG.  
-- The read/write protocol here is very simple but suffices for low read and write
-- rates.
--
entity LPDDRControl_2channel is
port
  (
	--
	-- Physical memory signals
	--
   mcb3_dram_dq                            : inout  std_logic_vector(DDR_NUM_DQ_PINS-1 downto 0);
   mcb3_dram_a                             : out std_logic_vector(DDR_ADDR_WIDTH-1 downto 0);
   mcb3_dram_ba                            : out std_logic_vector(DDR_BANK_WIDTH-1 downto 0);
   mcb3_dram_cke                           : out std_logic;
   mcb3_dram_ras_n                         : out std_logic;
   mcb3_dram_cas_n                         : out std_logic;
   mcb3_dram_we_n                          : out std_logic;
   mcb3_dram_dm                            : out std_logic;
   mcb3_dram_udqs                          : inout  std_logic;
   mcb3_rzq                                : inout  std_logic;
   mcb3_dram_udm                           : out std_logic;
   c3_sys_clk                              : in  std_logic;
   c3_sys_rst_n                            : in  std_logic;
   c3_calib_done                           : out std_logic;
   c3_clk0                                 : out std_logic;
   c3_rst0                                 : out std_logic;
   mcb3_dram_dqs                           : inout  std_logic;
   mcb3_dram_ck                            : out std_logic;
   mcb3_dram_ck_n                          : out std_logic;
	
	--
	-- Clock for user logic
	--
	clk			:	in	std_logic;
	--
	-- User signals
	--
	trigWrite	:	in std_logic_vector(NM-1 downto 0);
	trigRead		:	in std_logic_vector(NM-1 downto 0);
	dataIn		:	in mem_data_array(NM-1 downto 0);
	dataOut		:	out mem_data_array(NM-1 downto 0);
	dataReady	:	out std_logic_vector(NM-1 downto 0);
	addrRead		:	in	mem_addr_array(NM-1 downto 0);
	addrWrite	:	in	mem_addr_array(NM-1 downto 0);
	
	rd_error	:	out	std_logic_vector(NM-1 downto 0);
	wr_error	:	out	std_logic_vector(NM-1 downto 0)
	);
end LPDDRControl_2channel;

architecture Behavioral of LPDDRControl_2channel is


component s6_lpddr_2channel is
generic
  (
            C3_P0_MASK_SIZE           : integer := 4;
          C3_P0_DATA_PORT_SIZE      : integer := 32;
          C3_P1_MASK_SIZE           : integer := 4;
          C3_P1_DATA_PORT_SIZE      : integer := 32;
    C3_MEMCLK_PERIOD        : integer := 10000; 
                                       -- Memory data transfer clock period.
    C3_RST_ACT_LOW          : integer := 0; 
                                       -- # = 1 for active low reset,
                                       -- # = 0 for active high reset.
    C3_INPUT_CLK_TYPE       : string := "SINGLE_ENDED"; 
                                       -- input clock type DIFFERENTIAL or SINGLE_ENDED.
    C3_CALIB_SOFT_IP        : string := "TRUE"; 
                                       -- # = TRUE, Enables the soft calibration logic,
                                       -- # = FALSE, Disables the soft calibration logic.
    C3_SIMULATION           : string := "FALSE"; 
                                       -- # = TRUE, Simulating the design. Useful to reduce the simulation time,
                                       -- # = FALSE, Implementing the design.
    DEBUG_EN                : integer := 0; 
                                       -- # = 1, Enable debug signals/controls,
                                       --   = 0, Disable debug signals/controls.
    C3_MEM_ADDR_ORDER       : string := "ROW_BANK_COLUMN"; 
                                       -- The order in which user address is provided to the memory controller,
                                       -- ROW_BANK_COLUMN or BANK_ROW_COLUMN.
    C3_NUM_DQ_PINS          : integer := 16; 
                                       -- External memory data width.
    C3_MEM_ADDR_WIDTH       : integer := 13; 
                                       -- External memory address width.
    C3_MEM_BANKADDR_WIDTH   : integer := 2 
                                       -- External memory bank address width.
  );
   
  port
  (

   mcb3_dram_dq                            : inout  std_logic_vector(C3_NUM_DQ_PINS-1 downto 0);
   mcb3_dram_a                             : out std_logic_vector(C3_MEM_ADDR_WIDTH-1 downto 0);
   mcb3_dram_ba                            : out std_logic_vector(C3_MEM_BANKADDR_WIDTH-1 downto 0);
   mcb3_dram_cke                           : out std_logic;
   mcb3_dram_ras_n                         : out std_logic;
   mcb3_dram_cas_n                         : out std_logic;
   mcb3_dram_we_n                          : out std_logic;
   mcb3_dram_dm                            : out std_logic;
   mcb3_dram_udqs                          : inout  std_logic;
   mcb3_rzq                                : inout  std_logic;
   mcb3_dram_udm                           : out std_logic;
   c3_sys_clk                              : in  std_logic;
   c3_sys_rst_i                            : in  std_logic;
   c3_calib_done                           : out std_logic;
   c3_clk0                                 : out std_logic;
   c3_rst0                                 : out std_logic;
   mcb3_dram_dqs                           : inout  std_logic;
   mcb3_dram_ck                            : out std_logic;
   mcb3_dram_ck_n                          : out std_logic;
   c3_p0_cmd_clk                           : in std_logic;
   c3_p0_cmd_en                            : in std_logic;
   c3_p0_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p0_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p0_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p0_cmd_empty                         : out std_logic;
   c3_p0_cmd_full                          : out std_logic;
   c3_p0_wr_clk                            : in std_logic;
   c3_p0_wr_en                             : in std_logic;
   c3_p0_wr_mask                           : in std_logic_vector(C3_P0_MASK_SIZE - 1 downto 0);
   c3_p0_wr_data                           : in std_logic_vector(C3_P0_DATA_PORT_SIZE - 1 downto 0);
   c3_p0_wr_full                           : out std_logic;
   c3_p0_wr_empty                          : out std_logic;
   c3_p0_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p0_wr_underrun                       : out std_logic;
   c3_p0_wr_error                          : out std_logic;
   c3_p0_rd_clk                            : in std_logic;
   c3_p0_rd_en                             : in std_logic;
   c3_p0_rd_data                           : out std_logic_vector(C3_P0_DATA_PORT_SIZE - 1 downto 0);
   c3_p0_rd_full                           : out std_logic;
   c3_p0_rd_empty                          : out std_logic;
   c3_p0_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p0_rd_overflow                       : out std_logic;
   c3_p0_rd_error                          : out std_logic;
   c3_p1_cmd_clk                           : in std_logic;
   c3_p1_cmd_en                            : in std_logic;
   c3_p1_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p1_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p1_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p1_cmd_empty                         : out std_logic;
   c3_p1_cmd_full                          : out std_logic;
   c3_p1_wr_clk                            : in std_logic;
   c3_p1_wr_en                             : in std_logic;
   c3_p1_wr_mask                           : in std_logic_vector(C3_P1_MASK_SIZE - 1 downto 0);
   c3_p1_wr_data                           : in std_logic_vector(C3_P1_DATA_PORT_SIZE - 1 downto 0);
   c3_p1_wr_full                           : out std_logic;
   c3_p1_wr_empty                          : out std_logic;
   c3_p1_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p1_wr_underrun                       : out std_logic;
   c3_p1_wr_error                          : out std_logic;
   c3_p1_rd_clk                            : in std_logic;
   c3_p1_rd_en                             : in std_logic;
   c3_p1_rd_data                           : out std_logic_vector(C3_P1_DATA_PORT_SIZE - 1 downto 0);
   c3_p1_rd_full                           : out std_logic;
   c3_p1_rd_empty                          : out std_logic;
   c3_p1_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p1_rd_overflow                       : out std_logic;
   c3_p1_rd_error                          : out std_logic
  );
end component;

--------------------------------------------
--------- Memory Signals  ------------------
--------------------------------------------
signal cmd_en, cmd_empty, cmd_full	:	std_logic_vector(NM-1 downto 0)	:= (others => '0');
signal cmd_instr	:	mem_instr_array(NM-1 downto 0)	:=	(others => (others => '0'));
signal cmd_bl		:	burst_length_array(NM-1 downto 0)	:= (others => (others => '0'));
signal cmd_addr, cmdAddrRead, cmdAddrWrite	:	mem_addr_full_array(NM-1 downto 0) := (others => (others => '0'));

signal wr_en, wr_full, wr_empty, wr_underrun	:	std_logic_vector(NM-1 downto 0) := (others => '0');
signal wr_mask		:	mem_mask_array(NM-1 downto 0) 	:= (others => (others => '0'));
signal wr_count	: 	mem_count_array(NM-1 downto 0)	:=	(others => (others => '0'));
signal wr_data		:	mem_data_array(NM-1 downto 0)	:=	(others => (others => '0'));

signal rd_en, rd_full, rd_empty, rd_overflow	:	std_logic_vector(NM-1 downto 0) := (others => '0');
signal rd_count	: 	mem_count_array(NM-1 downto 0)	:=	(others => (others => '0'));
signal rd_data		:	mem_data_array(NM-1 downto 0)	:=	(others => (others => '0'));


---------------------------------------------
----- State Machine Signals  ----------------
---------------------------------------------
signal stateWrite	: mem_state_array(NM-1 downto 0)	:=	(others => (others => '0'));
signal stateRead		: mem_state_array(NM-1 downto 0)	:=	(others => (others => '0'));


begin


MemWrapper: s6_lpddr_2channel port map (
	mcb3_dram_dq => mcb3_dram_dq,
   mcb3_dram_a => mcb3_dram_a,
   mcb3_dram_ba => mcb3_dram_ba,
   mcb3_dram_cke => mcb3_dram_cke,
   mcb3_dram_ras_n => mcb3_dram_ras_n,
   mcb3_dram_cas_n => mcb3_dram_cas_n,
   mcb3_dram_we_n => mcb3_dram_we_n,
   mcb3_dram_dm => mcb3_dram_dm,
   mcb3_dram_udqs => mcb3_dram_udqs,
   mcb3_rzq => mcb3_rzq,
   mcb3_dram_udm => mcb3_dram_udm,
   c3_sys_clk => c3_sys_clk,
   c3_sys_rst_i => c3_sys_rst_n,
   c3_calib_done => c3_calib_done,
   c3_clk0 => c3_clk0,
   c3_rst0 => c3_rst0,
   mcb3_dram_dqs => mcb3_dram_dqs,
   mcb3_dram_ck => mcb3_dram_ck,
   mcb3_dram_ck_n => mcb3_dram_ck_n,
	
	--Port 0
   c3_p0_cmd_clk => clk,
   c3_p0_cmd_en => cmd_en(0),
   c3_p0_cmd_instr => cmd_instr(0),
   c3_p0_cmd_bl => cmd_bl(0),
   c3_p0_cmd_byte_addr => cmd_addr(0),
   c3_p0_cmd_empty => cmd_empty(0),
   c3_p0_cmd_full => cmd_full(0),
   c3_p0_wr_clk => clk,
   c3_p0_wr_en => wr_en(0),
   c3_p0_wr_mask => wr_mask(0),
   c3_p0_wr_data => wr_data(0),
   c3_p0_wr_full => wr_full(0),
   c3_p0_wr_empty => wr_empty(0),
   c3_p0_wr_count => wr_count(0),
   c3_p0_wr_underrun => wr_underrun(0),
   c3_p0_wr_error => wr_error(0),
   c3_p0_rd_clk => clk,
   c3_p0_rd_en => rd_en(0),
   c3_p0_rd_data => rd_data(0),
   c3_p0_rd_full => rd_full(0),
   c3_p0_rd_empty => rd_empty(0),
   c3_p0_rd_count => rd_count(0),
   c3_p0_rd_overflow => rd_overflow(0),
   c3_p0_rd_error => rd_error(0),
	
	--Port 1
   c3_p1_cmd_clk => clk,
   c3_p1_cmd_en => cmd_en(1),
   c3_p1_cmd_instr => cmd_instr(1),
   c3_p1_cmd_bl => cmd_bl(1),
   c3_p1_cmd_byte_addr => cmd_addr(1),
   c3_p1_cmd_empty => cmd_empty(1),
   c3_p1_cmd_full => cmd_full(1),
   c3_p1_wr_clk => clk,
   c3_p1_wr_en => wr_en(1),
   c3_p1_wr_mask => wr_mask(1),
   c3_p1_wr_data => wr_data(1),
   c3_p1_wr_full => wr_full(1),
   c3_p1_wr_empty => wr_empty(1),
   c3_p1_wr_count => wr_count(1),
   c3_p1_wr_underrun => wr_underrun(1),
   c3_p1_wr_error => wr_error(1),
   c3_p1_rd_clk => clk,
   c3_p1_rd_en => rd_en(1),
   c3_p1_rd_data => rd_data(1),
   c3_p1_rd_full => rd_full(1),
   c3_p1_rd_empty => rd_empty(1),
   c3_p1_rd_count => rd_count(1),
   c3_p1_rd_overflow => rd_overflow(1),
   c3_p1_rd_error => rd_error(1)
	
);


StateMachineGenerate:
for I in 0 to NM-1 generate

StateMachineX: process(clk,trigWrite(I),trigRead(I)) is
begin
	if rising_edge(clk) then
		--
		-- This case statement handles the process of writing data to
		-- the memory.
		--
		WriteCaseX: case stateWrite(I) is
			--
			-- Idle state.  Waits for a write trigger, 
			-- then latches the write address into an internal signal
			--
			when X"0" =>
				if trigWrite(I) = '1' then
					wr_data(I) <= dataIn(I);
					cmdAddrWrite(I) <= std_logic_vector(addrWrite(I)) & "00";
					stateWrite(I) <= stateWrite(I) + X"1";
				end if;
			
			--
			-- Wait until the write buffer has room and no read transactions
			-- are occurring.  Then tell the controller that a write instruction
			-- follows with one memory location to be written to.
			--
			-- Data is written into the write buffer on subsequent clock edges
			--
			when X"1" =>
				if wr_full(I) = '0' and stateRead(I) = X"0" then
					wr_en(I) <= '1';
					stateWrite(I) <= stateWrite(I) + X"1";
					cmd_instr(I) <= "000";		--This specifies a write command
					cmd_bl(I) <= "000000";
					cmd_addr(I) <= cmdAddrWrite(I);
				end if;
			
			--
			-- De-asserts the write-enable signal
			--
			when X"2" =>
				wr_en(I) <= '0';
				stateWrite(I) <= stateWrite(I) + X"1";
				
			--
			-- Waits for the write buffer to empty before proceeding
			--
			when X"3" => 
				if wr_empty(I) = '0' then
					stateWrite(I) <= stateWrite(I) +X"1";
				end if;
				
			--
			-- This is the actual command that writes data from
			-- the write buffer into the memory
			--
			when X"4" =>
				cmd_en(I) <= '1';
				stateWrite(I) <= stateWrite(I) + X"1";
				
			--
			-- De-assert the cmd_en signal.
			--
			when X"5" =>
				cmd_en(I) <= '0';
				stateWrite(I) <= stateWrite(I) + X"1";
				
			--
			-- Wait until the write buffer is empty before
			-- returning to the idle state
			--
			when X"6" =>
				if wr_empty(I) = '1' then
					stateWrite(I) <= X"0";
				end if;
			
			when others => null;
		end case;
		
		--
		-- This case statement handles the process of reading data
		-- from the memory.
		--
		ReadCaseX: case stateRead(I) is
			--
			-- Idle state.  Waits for a read trigger, then latches the address
			-- into an internral signal.
			--
			when X"0" =>
				if trigRead(I) = '1' then
					cmdAddrRead(I) <= std_logic_vector(addrRead(I)) & "00";					
					stateRead(I) <= stateRead(I) + X"1";
				else
					dataReady(I) <= '0';
				end if;
			
			--
			-- Waits until the read buffer is empty and no write transactions are occurring.
			-- Sends address to command signal for memory.
			--
			when X"1" =>
				if rd_empty(I) = '1' and (stateWrite(I) = X"0" or stateWrite(I) = X"1") then
					cmd_instr(I) <= "001";		--This specifies a read command
					cmd_bl(I) <= "000000";
					cmd_addr(I) <= cmdAddrRead(I);
					stateRead(I) <= stateRead(I) + X"1";
				end if;
				
			--
			-- Assert the cmd_en signal to write the cmd_instr to the
			-- controller
			--
			when X"2" =>
				cmd_en(I) <= '1';
				stateRead(I) <= stateRead(I) + X"1";
				
			--
			-- De-assert the cmd_en signal
			--
			when X"3" =>
				cmd_en(I) <= '0';
				stateRead(I) <= stateRead(I) + X"1";
				
			--
			-- Wait until the read buffer has data before proceeding
			--
			when X"4" =>
				if rd_empty(I) = '0' then
					stateRead(I) <= stateRead(I) + X"1";
				end if;
				
			--
			-- Assert the rd_en signal to start pulling data from the read buffer
			--
			when X"5" =>
				rd_en(I) <= '1';
				stateRead(I) <= stateRead(I) + X"1";
			
			--
			-- Read data is now valid.  Retrieve the data from the read buffer (rd_data)
			-- and assert that the data is valid to outside entities.
			--
			when X"6" =>
				rd_en(I) <= '0';
				dataOut(I) <= rd_data(I);
				dataReady(I) <= '1';
				stateRead(I) <= stateRead(I) + X"1";
			
			--
			-- De-assert the dataReady signal and return to idle state
			--
			when X"7" =>
				stateRead(I) <= X"0";
				dataReady(I) <= '0';
		
			when others => null;
		end case;
	end if;	--End rising_edge
end process;

end generate StateMachineGenerate;


end Behavioral;

